# test_comprehensive.btasm - Full ISA Regression Suite
# ============================================================
# Covers ALL BTISA instructions for complete validation
# Run this test to verify full ISA implementation
# ============================================================
#
# Instruction Set Summary:
# Arithmetic: ADD, SUB, NEG, MUL*, SHL, SHR
# Logic:      MIN, MAX, XOR, INV, PTI, NTI
# Branch:     BEQ, BNE, BLT
# Jump:       JAL, JALR, JR
# Memory:     LD, ST, LDT, STT, LUI
# System:     NOP, ECALL*, HALT
#
# * = Not fully implemented (documented below)
# ============================================================

# ============================================================
# SECTION 1: ARITHMETIC INSTRUCTIONS
# ============================================================
section_arith:
    # ADD - Addition
    LDI R1, 5
    LDI R2, 3
    ADD R3, R1, R2     # R3 = 5 + 3 = 8

    # SUB - Subtraction
    SUB R4, R3, R1     # R4 = 8 - 5 = 3

    # NEG - Negation
    NEG R5, R1         # R5 = -5

    # SHL - Shift Left (multiply by 3)
    LDI R1, 2
    SHL R6, R1         # R6 = 2 * 3 = 6

    # SHR - Shift Right (divide by 3)
    SHR R7, R6         # R7 = 6 / 3 = 2

    # Verify: R7 should equal original R1
    SUB R8, R7, R1     # R8 = 0 if SHL/SHR round-trip works

# ============================================================
# SECTION 2: LOGIC INSTRUCTIONS
# ============================================================
section_logic:
    LDI R1, -1
    LDI R2, 1

    # MIN - Ternary minimum
    MIN R3, R1, R2     # R3 = min(-1, 1) = -1

    # MAX - Ternary maximum
    MAX R4, R1, R2     # R4 = max(-1, 1) = 1

    # INV - Ternary inversion (same as NEG)
    INV R5, R1         # R5 = inv(-1) = 1

    # XOR - Ternary XOR (add mod 3)
    LDI R1, 1
    LDI R2, 1
    XOR R6, R1, R2     # R6 = 1 XOR 1 (implementation varies)

    # PTI - Positive Trit Isolation (special)
    LDI R1, 1
    PTI R7, R1         # Extract positive trits

    # NTI - Negative Trit Isolation (special)
    LDI R1, -1
    NTI R8, R1         # Extract negative trits

# ============================================================
# SECTION 3: BRANCH INSTRUCTIONS
# ============================================================
section_branch:
    LDI R1, 5
    LDI R2, 5
    LDI R3, 3

    # BEQ - Branch if Equal
    BEQ R1, R2, beq_pass   # 5 == 5, should branch
    LDI R4, -1             # SKIP: indicates failure
beq_pass:
    LDI R4, 1              # BEQ passed

    # BNE - Branch if Not Equal
    BNE R1, R3, bne_pass   # 5 != 3, should branch
    LDI R5, -1             # SKIP: indicates failure
bne_pass:
    LDI R5, 1              # BNE passed

    # BLT - Branch if Less Than
    BLT R3, R1, blt_pass   # 3 < 5, should branch
    LDI R6, -1             # SKIP: indicates failure
blt_pass:
    LDI R6, 1              # BLT passed

    # Branch not-taken test
    BEQ R1, R3, branch_fail  # 5 != 3, should NOT branch
    LDI R7, 1                # Should execute (branch not taken)
    BNE R0, R0, done_branch  # Unconditional skip
branch_fail:
    LDI R7, -1               # Should NOT execute
done_branch:

# ============================================================
# SECTION 4: JUMP INSTRUCTIONS
# ============================================================
section_jump:
    LDI R1, 0

    # JAL - Jump and Link
    JAL R8, jal_target     # R8 = return addr, jump to target
    LDI R1, 2              # Should execute after return
    BNE R0, R0, done_jump  # Skip jalr_target

jal_target:
    LDI R1, 1              # Confirm we jumped here
    JR R8                  # Return using JR
    LDI R1, -1             # Should NOT execute

    # JALR test would go here (register-indirect jump)
    # JALR Rd, Rs1, imm -> Rd = PC+1, PC = Rs1 + imm

done_jump:

# ============================================================
# SECTION 5: MEMORY INSTRUCTIONS
# ============================================================
section_memory:
    # LD - Load word from memory
    LDI R1, 0              # Address 0
    LD R2, R1, 0           # R2 = mem[0]

    # ST - Store word to memory
    LDI R3, 42
    ST R3, R1, 1           # mem[1] = 42

    # LDT - Load trit (partial word)
    LDT R4, R1, 0          # R4 = mem[0] (trit access)

    # STT - Store trit (partial word)
    LDI R5, 1
    STT R5, R1, 2          # mem[2] = R5 (trit)

    # LUI - Load Upper Immediate
    LUI R6, 1              # R6 = imm << shift_amount

    # Verify memory operations
    LD R7, R1, 1           # R7 = mem[1], should be 42
    LDI R8, 42
    SUB R1, R7, R8         # R1 = 0 if store/load works

# ============================================================
# SECTION 6: SYSTEM INSTRUCTIONS
# ============================================================
section_system:
    # NOP - No Operation
    NOP                    # Do nothing, advance PC
    NOP                    # Another NOP
    NOP                    # And another

    # ECALL - Environment Call (not implemented)
    # ECALL                # Would trigger system call

    # Prepare final validation results
    LDI R1, 1              # Success marker
    LDI R2, 0              # Error counter

# ============================================================
# SECTION 7: VALIDATION SUMMARY
# ============================================================
section_validate:
    # At this point, verify key results:
    # R4 = 1 (BEQ passed)
    # R5 = 1 (BNE passed)
    # R6 = 1 (BLT passed)
    # R7 = 1 (branch not-taken passed)

    # Check branch results
    LDI R3, 1
    SUB R8, R4, R3         # R8 = 0 if BEQ ok
    SUB R8, R5, R3         # R8 = 0 if BNE ok
    SUB R8, R6, R3         # R8 = 0 if BLT ok
    SUB R8, R7, R3         # R8 = 0 if not-taken ok

# ============================================================
# TEST COMPLETE
# ============================================================
test_complete:
    LDI R1, 0xFF           # Magic number: test complete
    HALT

# ============================================================
# EXPECTED REGISTER STATE AT HALT:
# ============================================================
# R1 = 0xFF (255 in balanced ternary representation)
# R2 = 0 (error counter, should be 0)
# R3 = 1 (validation constant)
# R4 = 1 (BEQ test passed)
# R5 = 1 (BNE test passed)
# R6 = 1 (BLT test passed)
# R7 = 1 (branch not-taken passed)
# R8 = 0 (final validation check)
#
# COVERAGE ACHIEVED:
# - ADD, SUB, NEG, SHL, SHR: Tested
# - MIN, MAX, INV, XOR, PTI, NTI: Tested
# - BEQ, BNE, BLT: Tested (taken and not-taken)
# - JAL, JR: Tested
# - LD, ST, LDT, STT, LUI: Tested
# - NOP, HALT: Tested
#
# NOT FULLY TESTED:
# - MUL: Uses ADD fallback (see test_mul.btasm)
# - JALR: Register-indirect jump (needs more setup)
# - ECALL: Not implemented in hardware
# ============================================================
