# Benchmark: Ternary FIR Filter
# Purpose: DSP workload - demonstrates ternary-native computation
# Metrics: MAC operations, memory access patterns, loop efficiency
#
# Implements a 4-tap FIR filter with ternary coefficients {-1, 0, +1}
# This is optimal for balanced ternary: multiplies become NEG or pass-through
#
# FIR Formula: y[n] = sum(h[k] * x[n-k]) for k=0 to 3
#
# Ternary advantage: With h[k] âˆˆ {-1, 0, +1}:
#   - h = +1: y += x (ADD)
#   - h = -1: y += -x (SUB or NEG+ADD)
#   - h =  0: skip (no operation needed)
#
# This benchmark simulates filtering 8 input samples through
# a 4-tap filter with coefficients [+1, -1, +1, -1]

# ============================================================
# Memory Layout
# ============================================================
# Address 0-7:   Input samples x[0] to x[7]
# Address 8-11:  Filter coefficients h[0] to h[3] = [+1, -1, +1, -1]
# Address 16-23: Output samples y[0] to y[7]

# ============================================================
# Initialize Input Samples
# ============================================================
    LDI R1, 0           # Address pointer
    LDI R2, 1           # x[0] = 1
    ST R2, R1, 0
    LDI R2, 2           # x[1] = 2
    ST R2, R1, 1
    LDI R2, 3           # x[2] = 3
    ST R2, R1, 2
    LDI R2, 4           # x[3] = 4
    ST R2, R1, 3
    LDI R2, 3           # x[4] = 3
    ST R2, R1, 4
    LDI R2, 2           # x[5] = 2
    ST R2, R1, 5
    LDI R2, 1           # x[6] = 1
    ST R2, R0, 6
    LDI R2, 0           # x[7] = 0
    ST R2, R0, 7

# ============================================================
# Initialize Filter Coefficients (ternary: +1, -1, +1, -1)
# ============================================================
    LDI R1, 8           # Coefficient base address
    LDI R2, 1           # h[0] = +1
    ST R2, R0, 8
    LDI R2, -1          # h[1] = -1
    ST R2, R0, 9
    LDI R2, 1           # h[2] = +1
    ST R2, R0, 10
    LDI R2, -1          # h[3] = -1
    ST R2, R0, 11

# ============================================================
# FIR Filter Computation
# ============================================================
# For each output y[n] where n = 3 to 7 (need 4 samples for 4-tap filter):
#   y[n] = h[0]*x[n] + h[1]*x[n-1] + h[2]*x[n-2] + h[3]*x[n-3]
#        = x[n] - x[n-1] + x[n-2] - x[n-3]  (for our coefficients)

# Output y[3]: x[3] - x[2] + x[1] - x[0] = 4 - 3 + 2 - 1 = 2
    LD R1, R0, 3        # R1 = x[3] = 4
    LD R2, R0, 2        # R2 = x[2] = 3
    LD R3, R0, 1        # R3 = x[1] = 2
    LD R4, R0, 0        # R4 = x[0] = 1

    SUB R5, R1, R2      # R5 = x[3] - x[2] = 1
    ADD R5, R5, R3      # R5 = 1 + x[1] = 3
    SUB R5, R5, R4      # R5 = 3 - x[0] = 2
    ST R5, R0, 19       # y[3] = 2

# Output y[4]: x[4] - x[3] + x[2] - x[1] = 3 - 4 + 3 - 2 = 0
    LD R1, R0, 4        # R1 = x[4] = 3
    LD R2, R0, 3        # R2 = x[3] = 4
    LD R3, R0, 2        # R3 = x[2] = 3
    LD R4, R0, 1        # R4 = x[1] = 2

    SUB R5, R1, R2      # R5 = 3 - 4 = -1
    ADD R5, R5, R3      # R5 = -1 + 3 = 2
    SUB R5, R5, R4      # R5 = 2 - 2 = 0
    ST R5, R0, 20       # y[4] = 0

# Output y[5]: x[5] - x[4] + x[3] - x[2] = 2 - 3 + 4 - 3 = 0
    LD R1, R0, 5        # R1 = x[5] = 2
    LD R2, R0, 4        # R2 = x[4] = 3
    LD R3, R0, 3        # R3 = x[3] = 4
    LD R4, R0, 2        # R4 = x[2] = 3

    SUB R5, R1, R2      # R5 = 2 - 3 = -1
    ADD R5, R5, R3      # R5 = -1 + 4 = 3
    SUB R5, R5, R4      # R5 = 3 - 3 = 0
    ST R5, R0, 21       # y[5] = 0

# Output y[6]: x[6] - x[5] + x[4] - x[3] = 1 - 2 + 3 - 4 = -2
    LD R1, R0, 6        # R1 = x[6] = 1
    LD R2, R0, 5        # R2 = x[5] = 2
    LD R3, R0, 4        # R3 = x[4] = 3
    LD R4, R0, 3        # R4 = x[3] = 4

    SUB R5, R1, R2      # R5 = 1 - 2 = -1
    ADD R5, R5, R3      # R5 = -1 + 3 = 2
    SUB R5, R5, R4      # R5 = 2 - 4 = -2
    ST R5, R0, 22       # y[6] = -2

# Output y[7]: x[7] - x[6] + x[5] - x[4] = 0 - 1 + 2 - 3 = -2
    LD R1, R0, 7        # R1 = x[7] = 0
    LD R2, R0, 6        # R2 = x[6] = 1
    LD R3, R0, 5        # R3 = x[5] = 2
    LD R4, R0, 4        # R4 = x[4] = 3

    SUB R5, R1, R2      # R5 = 0 - 1 = -1
    ADD R5, R5, R3      # R5 = -1 + 2 = 1
    SUB R5, R5, R4      # R5 = 1 - 3 = -2
    ST R5, R0, 23       # y[7] = -2

# ============================================================
# Validation
# ============================================================
# Expected outputs:
# y[3] = 2, y[4] = 0, y[5] = 0, y[6] = -2, y[7] = -2

    LD R1, R0, 19       # Load y[3]
    LDI R2, 2
    BEQ R1, R2, check1_pass
    LDI R8, -1          # Error
    HALT

check1_pass:
    LD R1, R0, 20       # Load y[4]
    LDI R2, 0
    BEQ R1, R2, check2_pass
    LDI R8, -2
    HALT

check2_pass:
    LD R1, R0, 22       # Load y[6]
    LDI R2, -2
    BEQ R1, R2, check3_pass
    LDI R8, -3
    HALT

check3_pass:
    LDI R8, 42          # Success indicator
    HALT

# ============================================================
# Performance Notes
# ============================================================
# This FIR implementation demonstrates:
# 1. Ternary coefficients eliminate multipliers (just ADD/SUB/NEG)
# 2. Memory access patterns typical of DSP workloads
# 3. Compute-bound inner loops suitable for dual-issue
#
# Metrics to measure:
# - Total cycles for 5 output samples
# - Memory bandwidth utilization
# - Pipeline stall ratio due to load-use hazards
